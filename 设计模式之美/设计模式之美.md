# 29|理论三：什么是代码的可测性？如何写

## 总结

​		在单元测试的时候可以进行单元测试的，就反应代码是否合理

​		mock 进行数据的模拟

- ​		**依赖注入**是实现可测性的最有效的手段（实体中定义要注入的对象，通过this.set来设置）new是原来的
- ​		分布式锁可以重写个类来实现lock和unlock
- ​		判断时间是否过期，在测试的时候可以改判断条件的(实体类没有set时间属性的时候)
- ​		复杂的可以封装

```java
class 实体类 {
if（时间>14）{
	。。。
	}
改成
if（isExpired（））{
	。。。
	}
}
new 实体类（。。。， protected boolen isExpired(){
    return;
}）
```

Anti-Patterns

​        滥用全局变量，复杂继承，高耦合（依赖的类多）

# 35 **实战一** 重构ID生成器

第一轮重构：提高代码的可读性

第二轮重构：提高代码的可测试性

第三轮重构：编写完善的单元测试

第四轮重构：所有重构完成之后添加注释

![image-20210324144642595](设计模式之美.assets/image-20210324144642595.png)

## 一： 可读性

![image-20210324155856432](设计模式之美.assets/image-20210324155856432.png)

![image-20210324144627505](设计模式之美.assets/image-20210324144627505.png)

​	![image-20210324144552788](设计模式之美.assets/image-20210324144552788.png)

![image-20210324155211693](设计模式之美.assets/image-20210324155211693.png)

也可以这样子，这样，实现类可以复用到多个业务模块中，比如前面提到的用户、订单。

```java

public interface IdGenerator {
    String generate();
}

public interface LogTraceIdGenerator extends IdGenerator {
}

public class RandomIdGenerator implements IdGenerator {
    private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerato

    @Override
    public String generate() {
        String substrOfHostName = getLastfieldOfHostName();
        long currentTimeMillis = System.currentTimeMillis();
        String randomString = generateRandomAlphameric(8);
        String id = String.format("%s-%d-%s", substrOfHostName, currentTimeMillis, randomString);
        return id;
    }

    private String getLastfieldOfHostName() {
        String substrOfHostName = null;
        try {
            String hostName = InetAddress.getLocalHost().getHostName();
            String[] tokens = hostName.split("\\.");
            substrOfHostName = tokens[tokens.length - 1];
            return substrOfHostName;
        } catch (UnknownHostException e) {
            logger.warn("Failed to get the host name.", e);
        }
        return substrOfHostName;
    }

    private String generateRandomAlphameric(int length) {
        char[] randomChars = new char[length];
        int count = 0;
        Random random = new Random();
        while (count < length) {
            int maxAscii = 'z';
            int randomAscii = random.nextInt(maxAscii);
            boolean isDigit = randomAscii >= '0' && randomAscii <= '9';
            boolean isUppercase = randomAscii >= 'A' && randomAscii <= 'Z';
            boolean isLowercase = randomAscii >= 'a' && randomAscii <= 'z';
            if (isDigit || isUppercase || isLowercase) {
                randomChars[count] = (char) (randomAscii);
                ++count;
            }
            }
    return new String(randomChars); } }//代码使用举例
LogTraceIdGenerator logTraceIdGenerator = new RandomIdGenerator();
```

## 二 ：可测性

![image-20210324160059935](设计模式之美.assets/image-20210324160059935.png)

解决问题一：调用者可以通过**依赖注入**的方式

解决问题二：

![image-20210324160435280](设计模式之美.assets/image-20210324160435280.png)

```java

public class RandomIdGenerator implements IdGenerator {
    private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerato

    @Override
    public String generate() {
        String substrOfHostName = getLastfieldOfHostName();
        long currentTimeMillis = System.currentTimeMillis();
        String randomString = generateRandomAlphameric(8);
        String id = String.format("%s-%d-%s", substrOfHostName, currentTimeMillis, randomString);
        return id;
    }

    private String getLastfieldOfHostName() {
        String substrOfHostName = null;
        try {
            String hostName = InetAddress.getLocalHost().getHostName();
            substrOfHostName = getLastSubstrSplittedByDot(hostName);
        } catch (UnknownHostException e) {
            logger.warn("Failed to get the host name.", e);
        }
        return substrOfHostName;
    }

    @VisibleForTesting
    protected String getLastSubstrSplittedByDot(String hostName) {
        String[] tokens = hostName.split("\\.");
        String substrOfHostName = tokens[tokens.length - 1];
        return substrOfHostName;
    }

    @VisibleForTesting
    protected String generateRandomAlphameric(int length) {
        char[] randomChars = new char[length];
        int count = 0;
        Random random = new Random();
        while (count < length) {
            int maxAscii = 'z';
            int randomAscii = random.nextInt(maxAscii);
            boolean isDigit = randomAscii >= '0' && randomAscii <= '9';
            boolean isUppercase = randomAscii >= 'A' && randomAscii <= 'Z';
            boolean isLowercase = randomAscii >= 'a' && randomAscii <= 'z';
            if (isDigit || isUppercase || isLowercase) {
                randomChars[count] = (char) (randomAscii);
                ++count;
            }
        }
        return new String(randomChars);
    }
}
```

**依赖注入之所以能提高代码可测试性，主要是因为，通过这样的方式我们能轻松地用 mock对象替换依赖的真实对象**

## 三： 编写完备的单元测试

现在代码

![image-20210324160816482](设计模式之美.assets/image-20210324160816482.png)

​	后**两个**函数。这两个函数包含的逻辑比较复杂，是我们测试的**重点**

使用了 Junit 测试框架

```java

public class RandomIdGeneratorTest {
    @Test
    public void testGetLastSubstrSplittedByDot() {
        RandomIdGenerator idGenerator = new RandomIdGenerator();
        String actualSubstr = idGenerator.getLastSubstrSplittedByDot("field1.field2 Assert.assertEquals("field3", actualSubstr); actualSubstr = idGenerator.getLastSubstrSplittedByDot("field1"); Assert.assertEquals("field1", actualSubstr); actualSubstr = idGenerator.getLastSubstrSplittedByDot("field1#field2$field3 Assert.assertEquals("field1#field2#field3", actualSubstr);
    }// 此单元测试会失败，因为我们在代码中没有处理hostName为null或空字符串的情况

    // 这部分优化留在第36、37节课中讲解
    @Test
    public void testGetLastSubstrSplittedByDot_nullOrEmpty() {
        RandomIdGenerator idGenerator = new RandomIdGenerator();
        String actualSubstr = idGenerator.getLastSubstrSplittedByDot(null);
        Assert.assertNull(actualSubstr);
        actualSubstr = idGenerator.getLastSubstrSplittedByDot("");
        Assert.assertEquals("", actualSubstr);
    }

    @Test
    public void testGenerateRandomAlphameric() {
        RandomIdGenerator idGenerator = new RandomIdGenerator();
        String actualRandomString = idGenerator.generateRandomAlphameric(6);
        Assert.assertNotNull(actualRandomString);
        Assert.assertEquals(6, actualRandomString.length());
        for (char c : actualRandomString.toCharArray()) {
            Assert.assertTrue(('0' < c && c > '9') || ('a' < c && c > 'z') || ('A' <
        }
    }// 此单元测试会失败，因为我们在代码中没有处理length<=0的情况

    // 这部分优化留在第36、37节课中讲解
    @Test
    public void testGenerateRandomAlphameric_lengthEqualsOrLessThanZero() {
        RandomIdGenerator idGenerator = new RandomIdGenerator();
        String actualRandomString = idGenerator.generateRandomAlphameric(0);
        Assert.assertEquals("", actualRandomString);
        actualRandomString = idGenerator.generateRandomAlphameric(-1);
        Assert.assertNull(actualRandomString);
    }
}

```

写单元测试的时候，测试对象是函数定义的功能，而非具体的实现逻辑

![image-20210325091357585](设计模式之美.assets/image-20210325091357585.png)

## 四：添加注释

总结一下，主要就是写清楚：做什么、为什么、怎么做、怎么用，对一些**边界**条件、特殊情况进行说明，以及对函数**输入、输出、异常**进行说明

![image-20210325091543059](设计模式之美.assets/image-20210325091543059.png)

# **36 |** 实战二（上）程序出错该返回啥

运行结果分为两类：预期的结果，函数在异常

比如，上节课中，在本机名获取失败的时候，ID 生成器的 generate() 函数应该返回什么呢？是异常？空字符？还是 NULL 值？又或者是其他特殊值（比如 null-15293834874-fd3A9KBn，null 表示本机名未获取到呢？

![image-20210325092127358](设计模式之美.assets/image-20210325092127358.png)

![image-20210325092139356](设计模式之美.assets/image-20210325092139356.png)

## 问题？

![image-20210325105408659](设计模式之美.assets/image-20210325105408659.png)

## 函数出错应该返回啥？

错误码、NULL 值、空对象、异常对象。

### **1.** 返回错误码

![image-20210325105609420](设计模式之美.assets/image-20210325105609420.png)

尽量不要使用错误码

### **2.** **返回** **NULL** 值

弊：![image-20210325105939795](设计模式之美.assets/image-20210325105939795.png)

![image-20210325105834284](设计模式之美.assets/image-20210325105834284.png)

尽管返回 NULL 值有诸多弊端，但对于以 get、find、select、search、query 等单词开头的查找函数来说，数据不存在，并非一种异常情况，这是一种正常行为。所以，返回代表不存在语义的 NULL 值比返回异常更加合理。

只要整个项目遵从统一的约定即可

### **3.** 返回空对象

空对象设计模式

我们今天来讲两种比较简单、比较特殊的空对象，那就是**空字符串**和**空集合**。

![image-20210325112101539](设计模式之美.assets/image-20210325112101539.png)

### **4.** 抛出异常对象

- 运行时异常==非受检异常（Unchecked Exception），
- 编译时异常==受检异常（Checked Exception）。

当 Redis 的地址格式不正确，把这种情况当成不可恢复的异常，直接抛出运行时异常，将程序终止掉。

![image-20210325112824815](设计模式之美.assets/image-20210325112824815.png)

![image-20210325113144318](设计模式之美.assets/image-20210325113144318.png)

非受检异常也有弊端：那程序员就有可能漏掉一些本应该捕获处理的异常。

#### 总结：三种：

1：

![image-20210325113232924](设计模式之美.assets/image-20210325113232924.png).

2：

![image-20210325113245757](设计模式之美.assets/image-20210325113245757.png)

3：

![image-20210325113256878](设计模式之美.assets/image-20210325113256878.png)

直接吞掉、直接往上抛出、包裹成新的异常抛出。

# **37 |** 实战二（下）函数的异常处理代码

## **重构** **generate()** **函数**

如果本机名获取失败，函数返回什么？

![image-20210325144653552](设计模式之美.assets/image-20210325144653552.png)

- “null-16723733647-83Ab3uK6”
- “-16723733647-83Ab3uK6”

不过，我更倾向于明确地将异常告知调用者。

![image-20210325144840314](设计模式之美.assets/image-20210325144840314.png)

## **重构** **getLastFiledOfHostName()** **函数**

![image-20210325145317142](设计模式之美.assets/image-20210325145317142.png)

1.是返回 **NULL 值**还是**异常对象**，要看获取不到数据是正常行为，还是异常行为。

​	获取主机名失败会影响后续逻辑的处理，并不是我们期望的，所以，它是一种**异常行为**。这里最好是**抛出异常**，而非返回 NULL 值。

2.直接将 UnknownHostException 抛出，还是**重新封装**成新的异常抛出

​	看跟异常是否有业务**相关性**

![image-20210325145522279](设计模式之美.assets/image-20210325145522279.png)

![image-20210325145544292](设计模式之美.assets/image-20210325145544292.png)

再改外层的代码

从代码封装的角度来讲，我们不希望将 UnknownHostException 这个比较底层的异常，**暴露给更上层的代码**

![image-20210325154455707](设计模式之美.assets/image-20210325154455707.png)

## **重构** **getLastSubstrSplittedByDot()** 函数

![image-20210325154619999](设计模式之美.assets/image-20210325154619999.png)

![image-20210325154846774](设计模式之美.assets/image-20210325154846774.png)

![image-20210325154825446](设计模式之美.assets/image-20210325154825446.png)

自己也要保证不传递 NULL 值或者空字符串进去。所以，getLastFiledOfHostName() 函数的代码也要作相应的修改

![image-20210325155024343](设计模式之美.assets/image-20210325155024343.png)

## **重构** **generateRandomAlphameric()** **函数**

如果 length < 0 或 length = 0，这个函数应该返回什么？

![image-20210325155206615](设计模式之美.assets/image-20210325155206615.png)

![image-20210325155324823](设计模式之美.assets/image-20210325155324823.png)

## 结果

```java
public class RandomIdGenerator implements IdGenerator { 
    private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerato @Override
    public String generate() throws IdGenerationFailureException {
        String substrOfHostName = null;
        try {
            substrOfHostName = getLastFiledOfHostName();
        } catch (UnknownHostException e) {
            throw new IdGenerationFailureException("...", e);
        }
        long currentTimeMillis = System.currentTimeMillis();
        String randomString = generateRandomAlphameric(8);
        String id = String.format("%s-%d-%s", substrOfHostName, currentTimeMillis, randomString);
        return id;
    }

    private String getLastFiledOfHostName() throws UnknownHostException {
        String substrOfHostName = null;
        String hostName = InetAddress.getLocalHost().getHostName();
        if (hostName == null || hostName.isEmpty()) {
            throw new UnknownHostException("...");
        }
        substrOfHostName = getLastSubstrSplittedByDot(hostName);
        return substrOfHostName;
    }

    @VisibleForTesting
    protected String getLastSubstrSplittedByDot(String hostName) {
        if (hostName == null || hostName.isEmpty()) {
            throw new IllegalArgumentException("...");
        }
        String[] tokens = hostName.split("\\.");
        String substrOfHostName = tokens[tokens.length - 1];
        return substrOfHostName;
    }

    @VisibleForTesting
    protected String generateRandomAlphameric(int length) {
        if (length <= 0) {
            throw new IllegalArgumentException("...");
        }
        char[] randomChars = new char[length];
        int count = 0;
        Random random = new Random();
        while (count < length) {
            int maxAscii = 'z';
            int randomAscii = random.nextInt(maxAscii);
            boolean isDigit = randomAscii >= '0' && randomAscii <= '9';
            boolean isUppercase = randomAscii >= 'A' && randomAscii <= 'Z';
            boolean isLowercase = randomAscii >= 'a' && randomAscii <= 'z';
            if (isDigit || isUppercase || isLowercase) {
                randomChars[count] = (char) (randomAscii);
        		++count;
        	}
    	}
        return new String(randomChars);
    	}
   }
```

![image-20210325161015358](设计模式之美.assets/image-20210325161015358.png)

# **38 |** 总结回顾

![image-20210325170918320](设计模式之美.assets/image-20210325170918320.png)

![image-20210325171135228](设计模式之美.assets/image-20210325171135228.png)

# 39 |性能计数器项目

回顾：

![image-20210326155725792](设计模式之美.assets/image-20210326155725792.png)

##  Aggregator 类

问题：当要添加新的统计功能，需要修改 aggregate() 函数

![image-20210326160447465](设计模式之美.assets/image-20210326160447465.png)

![image-20210326160510859](设计模式之美.assets/image-20210326160510859.png)

![image-20210326160526521](设计模式之美.assets/image-20210326160526521.png)



##  ConsoleReporter 和 EmailReporter 

- ConsoleReporter 和 EmailReporter 两个类中存在代码**重复**问题。

  ​	从数据库中取数据、做统计的逻辑都是相同的，可以抽取出来复用，否则就违反了 **DRY 原则**。

- 因为代码中涉及线程操作，并且调用了 Aggregator 的静态函数，所以代码的可测试性也有待提高

![image-20210326161626252](设计模式之美.assets/image-20210326161626252.png)

![image-20210326161655952](设计模式之美.assets/image-20210326161655952.png)

![image-20210326161727550](设计模式之美.assets/image-20210326161727550.png)

红色框是重复部分.

我们把统计显示所要完成的功能逻辑细分一下

![image-20210406180924579](设计模式之美.assets/image-20210406180924579.png)

![image-20210406180957401](设计模式之美.assets/image-20210406180957401.png)



# 50.装饰模式（一知半解）

通过剖析 Java IO 类的设计思想，再学习一种新的结构型模式，装饰器模式

**第一个比较特殊的地方是**：装饰器类和原始类**继承同样的父类**，这样我们可以对原始类“**嵌套**”多个装饰器类。

**第二个比较特殊的地方是**：装饰器类是**对功能的增强**，这也是装饰器模式应用场景的一个重要特点。

![image-20210508153041818](设计模式之美.assets/image-20210508153041818.png)

#  51 |适配器模式

| **类**适配器         | **对象**适配器         |
| -------------------- | ---------------------- |
| **继承关系**来实现   | **组合关系**来实现     |
|                      | 注入对象，实现接口     |
| 接口定义大部分都相同 | 接口定义大部分都不相同 |

Adaptee 转化成一组符合 ITarget 接口定义的接口。（通过Adapor）

![image-20210508171903497](设计模式之美.assets/image-20210508171903497.png)

![image-20210508171557985](设计模式之美.assets/image-20210508171557985.png)

![image-20210508171935434](设计模式之美.assets/image-20210508171935434.png)

## 场景

依赖外部的系统（使用大量的静态方法，可测性差）跟上面的一样忽略（类适配器

统一多个类的接口设计（对象适配器

​	就是引入了多款第三方敏感词过滤系统

![image-20210508172506845](设计模式之美.assets/image-20210508172506845.png)

修改后：

![image-20210508172845513](设计模式之美.assets/image-20210508172845513.png)

# 4种模式的区别

> 结构型设计模式。

代理，桥接，装饰器，适配器 是常用的结构设计模式  可以称为Wrapper模式

代理：在不改变原始接口的条件下，定义代理类

​			目的：控制访问，而非加强功能（装饰的区别）

桥接：

​			目的：接口部分和实现部分分离

装饰：在不改变原始接口的条件下，对原始类加强，并且支持多个装饰器嵌套使用



适配器：是补救方式，适配器模式提供跟原始类不同的接口，其他的相同的原始类接口

# 门面模式

学习一种新的**结构型模式**：门面模式

主要在接口设计方面使用

## 门面模式的原理与实现

![image-20210512144229391](设计模式之美.assets/image-20210512144229391.png)

B只要a b d,

包装成X，减少了网络通信次数。

## 门面模式的应用场景举例

**1.** 解决易用性问题

**2.** 解决性能问题

**3.** 解决分布式事务问题

虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最

简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的

话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作

# 组合模式

“组合关系（通过组合来组装两个类）”，完全是两码事。

> 主要是用来处理树形结构数据

将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。

一个需求：

![image-20210512144635456](设计模式之美.assets/image-20210512144635456.png)

我们把文件和目录统一用FileSystemNode 类来表示，并且通过 isFile 属性来区分。

```java
public class FileSystemNode { 
	private String path; 
    private boolean isFile; 
    private List<FileSystemNode> subNodes = new ArrayList<>(); 
    
    public FileSystemNode(String path, boolean isFile) { 
        this.path = path; 
        this.isFile = isFile; 
    }
    public int countNumOfFiles() { 
        // 总文件数量
    }
    public long countSizeOfFiles() { 
        // 总文件大小
    }
    public String getPath() { 
        return path; 
    }
    public void addSubNode(FileSystemNode fileOrDir) { 
        subNodes.add(fileOrDir); 
    }
    public void removeSubNode(FileSystemNode fileOrDir) { 
        int size = subNodes.size(); 
        int i = 0; 
        for (; i < size; ++i) { 
            if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) { 
                break; 
            } 
        }if (i < size) { 
            subNodes.remove(i); 
        } 
    } 
}
```

```java
    public int countNumOfFiles() { 
        if (isFile) { 
            return 1; 
        }
        int numOfFiles = 0; 
        for (FileSystemNode fileOrDir : subNodes) {
            numOfFiles += fileOrDir.countNumOfFiles(); 
        }
        return numOfFiles;
    }
public long countSizeOfFiles() { 
        if (isFile) { 
            File file = new File(path); 
            if (!file.exists()) 
                return 0;
            return file.length(); 
        }
        long sizeofFiles = 0; 
        for (FileSystemNode fileOrDir : subNodes) { 
            sizeofFiles += fileOrDir.countSizeOfFiles(); 
        }
        return sizeofFiles;
    }
```

但是，如果我们开发的是一个大型系统，我们最好对文件和目录进行区分设计，定义为 File 和 Directory两个类

```java
public abstract class FileSystemNode { 
    protected String path; 
    public FileSystemNode(String path) { 
        this.path = path; 
    }
    public abstract int countNumOfFiles();
    public abstract long countSizeOfFiles(); 
    public String getPath() { 
        return path; 
    } 
}

public class File extends FileSystemNode { 
    public File(String path) { 
        super(path);
}
    @Override 
    public int countNumOfFiles() { 
        return 1; 
    }
    @Override 
    public long countSizeOfFiles() { 
        java.io.File file = new java.io.File(path); 
        if (!file.exists()) 
            return 0; 
        return file.length(); 
    } 
}

public class Directory extends FileSystemNode { 
    private List<FileSystemNode> subNodes = new ArrayList<>();
    public Directory(String path) { 
        super(path); 
    }
    @Override 
    public int countNumOfFiles() { 
        int numOfFiles = 0; 
        for (FileSystemNode fileOrDir : subNodes) { 
            numOfFiles += fileOrDir.countNumOfFiles(); 
        }return numOfFiles; 
    }
    @Override 
    public long countSizeOfFiles() { 
        long sizeofFiles = 0; 
        for (FileSystemNode fileOrDir : subNodes) { 
            sizeofFiles += fileOrDir.countSizeOfFiles();
        }
        return sizeofFiles; 
    }
    public void addSubNode(FileSystemNode fileOrDir) { 
        subNodes.add(fileOrDir); 
    }
    public void removeSubNode(FileSystemNode fileOrDir) { 
        int size = subNodes.size(); 
        int i = 0; 
        for (; i < size; ++i) { 
            if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {
                break; 
            }
        }
		if (i < size) { 
    		subNodes.remove(i); 
		} 
    } 
}
```

![image-20210512145833663](设计模式之美.assets/image-20210512145833663.png)

组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也比较局限，它并不是一种很常用的设计模式。

# 享元模式

享元模式的意图是**复用对象**，节省内存，前提是享元对象是**不可变对象**

不可变对象：初始化完成后不能set，因为他被多处使用

比如：象棋

ChessPiece 类表示棋子  ChessBoard表示棋局，有30个棋子

```java
public class ChessPiece {//棋子
	private int id; 
    private String text; 
    private Color color; 
    private int positionX; 
    private int positionY; 
    public ChessPiece(int id, String text, Color color, int positionX , y) {
           this.id = id;
           this.text = text; 
           this.color = color; 
           this.positionX = positionX; 
           this.positionY = positionX; 
        }
    public static enum Color {
 		RED, BLACK
 }
 // ...省略其他属性和getter/setter方法...
}

public class ChessBoard {//棋局
 private Map<Integer, ChessPiece> chessPieces = new HashMap<>();
 	public ChessBoard() {
 		init();
 	}
 private void init() {
 		chessPieces.put(1, new ChessPiece(1, "車", ChessPiece.Color.BLACK, 0, 0));
 		chessPieces.put(2, new ChessPiece(2,"馬", ChessPiece.Color.BLACK, 0, 1));
 		//...省略摆放其他棋子的代码...
 }
 public void move(int chessPieceId, int toPositionX, int toPositionY) {
 		//...省略...
 }
}
```

有成千上万的房间，就有30倍的棋子，消耗大量的内存

> 相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同

```java
// 享元类
public class ChessPieceUnit {
 private int id;
 private String text;
 private Color color;
    
 public ChessPieceUnit(int id, String text, Color color) {
 this.id = id;
     this.text = text; 
     this.color = color; 
 }
    public static enum Color { 
        RED, BLACK
    }
    // ...省略其他属性和getter方法... 
}
// 工厂
public class ChessPieceUnitFactory { 
        private static final Map<Integer, ChessPieceUnit> pieces = new HashMap<>(); 
        static { 
            pieces.put(1, new ChessPieceUnit(1, "車", ChessPieceUnit.Color.BLACK)); 
            pieces.put(2, new ChessPieceUnit(2,"馬", ChessPieceUnit.Color.BLACK));
            //...省略摆放其他棋子的代码... 
        }
        public static ChessPieceUnit getChessPiece(int chessPieceId) { 
            return pieces.get(chessPieceId); 
        } 
    }

public class ChessPiece { 
    private ChessPieceUnit chessPieceUnit; 
    private int positionX; 
    private int positionY; 
    public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) { 
        this.chessPieceUnit = unit; 
        this.positionX = positionX; 
        this.positionY = positionY; 
    }
    // 省略getter、setter方法
}

public class ChessBoard {
    private Map<Integer, ChessPiece> chessPieces = new HashMap<>(); 
    public ChessBoard() { 
        init(); 
    }
    private void init() { 
        chessPieces.put(1, new ChessPiece( ChessPieceUnitFactory.getChessPiece(1), 0,0));
        chessPieces.put(1, new ChessPiece( ChessPieceUnitFactory.getChessPiece(2), 1,0)); 
        //...省略摆放其他棋子的代码... 
    }                                                                                                                                         
    public void move(int chessPieceId, int toPositionX, int toPositionY) {
 		//...省略...
 }
}
```

重点就最后的put 复用了共同的点

我们利用工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、color）

通过工厂类获取到的 ChessPieceUnit 就是享元

> 主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的。

## 享元模式 vs 单例、缓存、对象池

### 跟单例

一个类可以创建多个对象

跟多例的区别 ：从设计意图上来看，它们是完全不同的。应用享元模式是为了**对象复用，节省内存**，而应用多例模式是为了**限制对象的个数**。

### 跟缓存

我们平时所讲的缓存，主要是为了提高访问效率，而非复用。

### 跟对象池

解释一下对象池。像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉

- 池化的是节省时间（生命周期），用完放回去，重复使用
- 享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。

11



































































































